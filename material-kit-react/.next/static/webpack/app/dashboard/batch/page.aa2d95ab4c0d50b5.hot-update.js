"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/batch/page",{

/***/ "(app-pages-browser)/./src/components/dashboard/batch/fetchPredictions.js":
/*!************************************************************!*\
  !*** ./src/components/dashboard/batch/fetchPredictions.js ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchPredictions: function() { return /* binding */ fetchPredictions; }\n/* harmony export */ });\n// export const fetchPredictions = async (selectedDate, startTime, endTime) => {\n//   try {\n//     // 첫 번째 요청: receive_prediction API\n//     const response = await fetch(\"http://localhost:5000/batch/receive_prediction\", {\n//       method: \"POST\",\n//       headers: {\n//         \"Content-Type\": \"application/json\",\n//       },\n//       body: JSON.stringify({\n//         selected_date: selectedDate,\n//         start_time: startTime,\n//         end_time: endTime,\n//       }),\n//     });\n//     if (!response.ok) {\n//       throw new Error(\"Failed to fetch data from receive_prediction\");\n//     }\n//     const predictionData = await response.json(); // 예측 데이터 파싱\n//     // 두 번째 요청: send_pie API\n//     const pieResponse = await fetch(\"http://localhost:5000/batch/send_pie\", {\n//       method: \"POST\",\n//       headers: {\n//         \"Content-Type\": \"application/json\",\n//       },\n//       body: JSON.stringify({\n//         selected_date: selectedDate,\n//         start_time: startTime,\n//         end_time: endTime,\n//       }),\n//     });\n//     if (!pieResponse.ok) {\n//       throw new Error(\"Failed to fetch data from send_pie\");\n//     }\n//     const pieData = await pieResponse.json(); // 파이 데이터 파싱\n//     // 세 번째 요청: protocol_rate API\n//     const protocolResponse = await fetch(\"http://localhost:5000/batch/protocol_rate\", {\n//       method: \"POST\",\n//       headers: {\n//         \"Content-Type\": \"application/json\",\n//       },\n//       body: JSON.stringify({\n//         selected_date: selectedDate,\n//         start_time: startTime,\n//         end_time: endTime,\n//       }),\n//     });\n//     if (!protocolResponse.ok) {\n//       throw new Error(\"Failed to fetch data from protocol_rate\");\n//     }\n//     const protocolData = await protocolResponse.json(); // 프로토콜 데이터 파싱\n//     // 모든 데이터를 객체로 반환\n//     return {\n//       predictionData, // receive_prediction의 예측 메시지\n//       pieData,        // send_pie의 트래픽/앱 비율\n//       protocolData    // protocol_rate의 프로토콜 데이터\n//     };\n//   } catch (error) {\n//     console.error(\"Error in fetchPredictions:\", error);\n//     return null;\n//   }\n// };\nconst fetchPredictions = async (selectedDate, startTime, endTime)=>{\n    try {\n        // 1. receive_prediction API 호출\n        const receivePredictionResponse = await fetch(\"http://localhost:5000/batch/receive_prediction\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                date: selectedDate,\n                start_time: startTime,\n                end_time: endTime\n            })\n        });\n        if (!receivePredictionResponse.ok) {\n            throw new Error(\"Failed to fetch prediction data\");\n        }\n        const predictionData = await receivePredictionResponse.json();\n        console.log(\"Prediction Data:\", predictionData); // 예측 데이터를 로그로 출력\n        // 2. send_pie API 호출\n        const sendPieResponse = await fetch(\"http://localhost:5000/batch/send_pie?date=\".concat(selectedDate, \"&start_time=\").concat(startTime, \"&end_time=\").concat(endTime), {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        if (!sendPieResponse.ok) {\n            throw new Error(\"Failed to fetch pie chart data\");\n        }\n        const pieData = await sendPieResponse.json();\n        console.log(\"Pie Data:\", pieData); // 파이 데이터를 로그로 출력\n        // 3. protocol_rate API 호출\n        const protocolRateResponse = await fetch(\"http://localhost:5000/batch/protocol_rate?date=\".concat(selectedDate, \"&start_time=\").concat(startTime, \"&end_time=\").concat(endTime), {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        if (!protocolRateResponse.ok) {\n            throw new Error(\"Failed to fetch protocol rate data\");\n        }\n        const protocolData = await protocolRateResponse.json();\n        console.log(\"Protocol Rate Data:\", protocolData); // 프로토콜 데이터를 로그로 출력\n        // 모든 데이터를 한 객체로 반환\n        return {\n            predictionData,\n            pieData,\n            protocolData\n        };\n    } catch (error) {\n        console.error(\"Error fetching predictions:\", error);\n        return null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rhc2hib2FyZC9iYXRjaC9mZXRjaFByZWRpY3Rpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxnRkFBZ0Y7QUFDaEYsVUFBVTtBQUNWLHlDQUF5QztBQUN6Qyx1RkFBdUY7QUFDdkYsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQiw4Q0FBOEM7QUFDOUMsV0FBVztBQUNYLCtCQUErQjtBQUMvQix1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixZQUFZO0FBQ1osVUFBVTtBQUVWLDBCQUEwQjtBQUMxQix5RUFBeUU7QUFDekUsUUFBUTtBQUVSLGlFQUFpRTtBQUVqRSwrQkFBK0I7QUFDL0IsZ0ZBQWdGO0FBQ2hGLHdCQUF3QjtBQUN4QixtQkFBbUI7QUFDbkIsOENBQThDO0FBQzlDLFdBQVc7QUFDWCwrQkFBK0I7QUFDL0IsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsWUFBWTtBQUNaLFVBQVU7QUFFViw2QkFBNkI7QUFDN0IsK0RBQStEO0FBQy9ELFFBQVE7QUFFUiw2REFBNkQ7QUFFN0Qsb0NBQW9DO0FBQ3BDLDBGQUEwRjtBQUMxRix3QkFBd0I7QUFDeEIsbUJBQW1CO0FBQ25CLDhDQUE4QztBQUM5QyxXQUFXO0FBQ1gsK0JBQStCO0FBQy9CLHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLFlBQVk7QUFDWixVQUFVO0FBRVYsa0NBQWtDO0FBQ2xDLG9FQUFvRTtBQUNwRSxRQUFRO0FBRVIseUVBQXlFO0FBRXpFLHdCQUF3QjtBQUN4QixlQUFlO0FBQ2Ysc0RBQXNEO0FBQ3RELDhDQUE4QztBQUM5QyxtREFBbUQ7QUFDbkQsU0FBUztBQUNULHNCQUFzQjtBQUN0QiwwREFBMEQ7QUFDMUQsbUJBQW1CO0FBQ25CLE1BQU07QUFDTixLQUFLO0FBQ0UsTUFBTUEsbUJBQW1CLE9BQU9DLGNBQWNDLFdBQVdDO0lBQzlELElBQUk7UUFDRiwrQkFBK0I7UUFDL0IsTUFBTUMsNEJBQTRCLE1BQU1DLE1BQU0sa0RBQWtEO1lBQzlGQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQUVDLE1BQU1WO2dCQUFjVyxZQUFZVjtnQkFBV1csVUFBVVY7WUFBUTtRQUN0RjtRQUVBLElBQUksQ0FBQ0MsMEJBQTBCVSxFQUFFLEVBQUU7WUFDakMsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsTUFBTUMsaUJBQWlCLE1BQU1aLDBCQUEwQmEsSUFBSTtRQUMzREMsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQkgsaUJBQWtCLGlCQUFpQjtRQUVuRSxxQkFBcUI7UUFDckIsTUFBTUksa0JBQWtCLE1BQU1mLE1BQU0sNkNBQXdFSCxPQUEzQkQsY0FBYSxnQkFBb0NFLE9BQXRCRCxXQUFVLGNBQW9CLE9BQVJDLFVBQVc7WUFDM0lHLFFBQVE7WUFDUkMsU0FBUztnQkFBRSxnQkFBZ0I7WUFBbUI7UUFDaEQ7UUFFQSxJQUFJLENBQUNhLGdCQUFnQk4sRUFBRSxFQUFFO1lBQ3ZCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUVBLE1BQU1NLFVBQVUsTUFBTUQsZ0JBQWdCSCxJQUFJO1FBQzFDQyxRQUFRQyxHQUFHLENBQUMsYUFBYUUsVUFBVyxpQkFBaUI7UUFFckQsMEJBQTBCO1FBQzFCLE1BQU1DLHVCQUF1QixNQUFNakIsTUFBTSxrREFBNkVILE9BQTNCRCxjQUFhLGdCQUFvQ0UsT0FBdEJELFdBQVUsY0FBb0IsT0FBUkMsVUFBVztZQUNySkcsUUFBUTtZQUNSQyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtRQUNoRDtRQUVBLElBQUksQ0FBQ2UscUJBQXFCUixFQUFFLEVBQUU7WUFDNUIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsTUFBTVEsZUFBZSxNQUFNRCxxQkFBcUJMLElBQUk7UUFDcERDLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUJJLGVBQWdCLG1CQUFtQjtRQUV0RSxtQkFBbUI7UUFDbkIsT0FBTztZQUNMUDtZQUNBSztZQUNBRTtRQUNGO0lBQ0YsRUFBRSxPQUFPQyxPQUFPO1FBQ2ROLFFBQVFNLEtBQUssQ0FBQywrQkFBK0JBO1FBQzdDLE9BQU87SUFDVDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvZGFzaGJvYXJkL2JhdGNoL2ZldGNoUHJlZGljdGlvbnMuanM/YzMwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHBvcnQgY29uc3QgZmV0Y2hQcmVkaWN0aW9ucyA9IGFzeW5jIChzZWxlY3RlZERhdGUsIHN0YXJ0VGltZSwgZW5kVGltZSkgPT4ge1xyXG4vLyAgIHRyeSB7XHJcbi8vICAgICAvLyDssqsg67KI7Ke4IOyalOyyrTogcmVjZWl2ZV9wcmVkaWN0aW9uIEFQSVxyXG4vLyAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9iYXRjaC9yZWNlaXZlX3ByZWRpY3Rpb25cIiwge1xyXG4vLyAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4vLyAgICAgICBoZWFkZXJzOiB7XHJcbi8vICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuLy8gICAgICAgICBzZWxlY3RlZF9kYXRlOiBzZWxlY3RlZERhdGUsXHJcbi8vICAgICAgICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLFxyXG4vLyAgICAgICAgIGVuZF90aW1lOiBlbmRUaW1lLFxyXG4vLyAgICAgICB9KSxcclxuLy8gICAgIH0pO1xyXG5cclxuLy8gICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGRhdGEgZnJvbSByZWNlaXZlX3ByZWRpY3Rpb25cIik7XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgY29uc3QgcHJlZGljdGlvbkRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7IC8vIOyYiOy4oSDrjbDsnbTthLAg7YyM7IuxXHJcblxyXG4vLyAgICAgLy8g65GQIOuyiOynuCDsmpTssq06IHNlbmRfcGllIEFQSVxyXG4vLyAgICAgY29uc3QgcGllUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9iYXRjaC9zZW5kX3BpZVwiLCB7XHJcbi8vICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgIGhlYWRlcnM6IHtcclxuLy8gICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuLy8gICAgICAgfSxcclxuLy8gICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4vLyAgICAgICAgIHNlbGVjdGVkX2RhdGU6IHNlbGVjdGVkRGF0ZSxcclxuLy8gICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUsXHJcbi8vICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUsXHJcbi8vICAgICAgIH0pLFxyXG4vLyAgICAgfSk7XHJcblxyXG4vLyAgICAgaWYgKCFwaWVSZXNwb25zZS5vaykge1xyXG4vLyAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggZGF0YSBmcm9tIHNlbmRfcGllXCIpO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIGNvbnN0IHBpZURhdGEgPSBhd2FpdCBwaWVSZXNwb25zZS5qc29uKCk7IC8vIO2MjOydtCDrjbDsnbTthLAg7YyM7IuxXHJcblxyXG4vLyAgICAgLy8g7IS4IOuyiOynuCDsmpTssq06IHByb3RvY29sX3JhdGUgQVBJXHJcbi8vICAgICBjb25zdCBwcm90b2NvbFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjUwMDAvYmF0Y2gvcHJvdG9jb2xfcmF0ZVwiLCB7XHJcbi8vICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgIGhlYWRlcnM6IHtcclxuLy8gICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuLy8gICAgICAgfSxcclxuLy8gICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4vLyAgICAgICAgIHNlbGVjdGVkX2RhdGU6IHNlbGVjdGVkRGF0ZSxcclxuLy8gICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUsXHJcbi8vICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUsXHJcbi8vICAgICAgIH0pLFxyXG4vLyAgICAgfSk7XHJcblxyXG4vLyAgICAgaWYgKCFwcm90b2NvbFJlc3BvbnNlLm9rKSB7XHJcbi8vICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBkYXRhIGZyb20gcHJvdG9jb2xfcmF0ZVwiKTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICBjb25zdCBwcm90b2NvbERhdGEgPSBhd2FpdCBwcm90b2NvbFJlc3BvbnNlLmpzb24oKTsgLy8g7ZSE66Gc7Yag7L2cIOuNsOydtO2EsCDtjIzsi7FcclxuXHJcbi8vICAgICAvLyDrqqjrk6Ag642w7J207YSw66W8IOqwneyytOuhnCDrsJjtmZhcclxuLy8gICAgIHJldHVybiB7XHJcbi8vICAgICAgIHByZWRpY3Rpb25EYXRhLCAvLyByZWNlaXZlX3ByZWRpY3Rpb27snZgg7JiI7LihIOuplOyLnOyngFxyXG4vLyAgICAgICBwaWVEYXRhLCAgICAgICAgLy8gc2VuZF9waWXsnZgg7Yq4656Y7ZS9L+yVsSDruYTsnKhcclxuLy8gICAgICAgcHJvdG9jb2xEYXRhICAgIC8vIHByb3RvY29sX3JhdGXsnZgg7ZSE66Gc7Yag7L2cIOuNsOydtO2EsFxyXG4vLyAgICAgfTtcclxuLy8gICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGZldGNoUHJlZGljdGlvbnM6XCIsIGVycm9yKTtcclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH1cclxuLy8gfTtcclxuZXhwb3J0IGNvbnN0IGZldGNoUHJlZGljdGlvbnMgPSBhc3luYyAoc2VsZWN0ZWREYXRlLCBzdGFydFRpbWUsIGVuZFRpbWUpID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gMS4gcmVjZWl2ZV9wcmVkaWN0aW9uIEFQSSDtmLjstpxcclxuICAgIGNvbnN0IHJlY2VpdmVQcmVkaWN0aW9uUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9iYXRjaC9yZWNlaXZlX3ByZWRpY3Rpb25cIiwge1xyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZGF0ZTogc2VsZWN0ZWREYXRlLCBzdGFydF90aW1lOiBzdGFydFRpbWUsIGVuZF90aW1lOiBlbmRUaW1lIH0pLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFyZWNlaXZlUHJlZGljdGlvblJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHByZWRpY3Rpb24gZGF0YScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHByZWRpY3Rpb25EYXRhID0gYXdhaXQgcmVjZWl2ZVByZWRpY3Rpb25SZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zb2xlLmxvZygnUHJlZGljdGlvbiBEYXRhOicsIHByZWRpY3Rpb25EYXRhKTsgIC8vIOyYiOy4oSDrjbDsnbTthLDrpbwg66Gc6re466GcIOy2nOugpVxyXG5cclxuICAgIC8vIDIuIHNlbmRfcGllIEFQSSDtmLjstpxcclxuICAgIGNvbnN0IHNlbmRQaWVSZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjUwMDAvYmF0Y2gvc2VuZF9waWU/ZGF0ZT0ke3NlbGVjdGVkRGF0ZX0mc3RhcnRfdGltZT0ke3N0YXJ0VGltZX0mZW5kX3RpbWU9JHtlbmRUaW1lfWAsIHtcclxuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXNlbmRQaWVSZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwaWUgY2hhcnQgZGF0YScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBpZURhdGEgPSBhd2FpdCBzZW5kUGllUmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ1BpZSBEYXRhOicsIHBpZURhdGEpOyAgLy8g7YyM7J20IOuNsOydtO2EsOulvCDroZzqt7jroZwg7Lac66ClXHJcblxyXG4gICAgLy8gMy4gcHJvdG9jb2xfcmF0ZSBBUEkg7Zi47LacXHJcbiAgICBjb25zdCBwcm90b2NvbFJhdGVSZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjUwMDAvYmF0Y2gvcHJvdG9jb2xfcmF0ZT9kYXRlPSR7c2VsZWN0ZWREYXRlfSZzdGFydF90aW1lPSR7c3RhcnRUaW1lfSZlbmRfdGltZT0ke2VuZFRpbWV9YCwge1xyXG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXHJcbiAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghcHJvdG9jb2xSYXRlUmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcHJvdG9jb2wgcmF0ZSBkYXRhJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJvdG9jb2xEYXRhID0gYXdhaXQgcHJvdG9jb2xSYXRlUmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ1Byb3RvY29sIFJhdGUgRGF0YTonLCBwcm90b2NvbERhdGEpOyAgLy8g7ZSE66Gc7Yag7L2cIOuNsOydtO2EsOulvCDroZzqt7jroZwg7Lac66ClXHJcblxyXG4gICAgLy8g66qo65OgIOuNsOydtO2EsOulvCDtlZwg6rCd7LK066GcIOuwmO2ZmFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcHJlZGljdGlvbkRhdGEsXHJcbiAgICAgIHBpZURhdGEsXHJcbiAgICAgIHByb3RvY29sRGF0YSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByZWRpY3Rpb25zOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufTtcclxuIl0sIm5hbWVzIjpbImZldGNoUHJlZGljdGlvbnMiLCJzZWxlY3RlZERhdGUiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwicmVjZWl2ZVByZWRpY3Rpb25SZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0ZSIsInN0YXJ0X3RpbWUiLCJlbmRfdGltZSIsIm9rIiwiRXJyb3IiLCJwcmVkaWN0aW9uRGF0YSIsImpzb24iLCJjb25zb2xlIiwibG9nIiwic2VuZFBpZVJlc3BvbnNlIiwicGllRGF0YSIsInByb3RvY29sUmF0ZVJlc3BvbnNlIiwicHJvdG9jb2xEYXRhIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/dashboard/batch/fetchPredictions.js\n"));

/***/ })

});